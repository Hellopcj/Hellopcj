<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[photoPostName]]></title>
    <url>%2FHellopcj%2F2017%2F09%2F20%2FphotoPostName%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Facebook rebond 弹簧功能源码分析]]></title>
    <url>%2FHellopcj%2F2017%2F09%2F14%2Frebond%2F</url>
    <content type="text"><![CDATA[相信大家在项目上或多或少的用到了弹簧功能，比较常用和方便的就是facebook的开源库rebond,想要深入的了解这个开源库的使用方法就需要我们源码分析（read the fucking source code！）整个开源库的功能实现。我自己也通过rebond写了个demo 有兴趣的可以下载了解下（代码都有注释 适合菜鸟初学者了解 大神略过） 废话不多说，下面我们就开始分析源代码（very fucking detailed！） （一）rebond的配置 在gradle 进行配置： 123dependencies &#123;compile 'com.facebook.rebound:rebound:0.3.8'&#125; 或者maven部署rebond库 12345&lt;dependency&gt; &lt;groupId&gt;com.facebook.rebound&lt;/groupId&gt; &lt;artifactId&gt;rebound&lt;/artifactId&gt; &lt;version&gt;0.3.8&lt;/version&gt;&lt;/dependency&gt; 这时候我们可以看到rebond的目录结构： |– ui| |– utils （layout的工具类 提供create四个不同参数的layout布局 例如：宽高自适应父类布局等）| |– SpringConfiguratorView（弹簧（Spring） view 配置器Spring 配置信息 包含Spring张力值0-200 摩擦力0-50）|– AndroidSpringLooperFactory |– AnimationQueue|– BaseSpringSystem|– BuildConfig (包含了开源库rebond的版本信息等) |– ChoreographerCompat |– OrigamiValueConverter |– SimpleSpringListener （实现了SpringLsitener接口） |– Spring |– SpringChain |– SpringConfig |– SpringConfigRegistry |– SpringListener （包含Spring 四个运动状态的方法） |– SpringLooper |– SpringSystem |– SpringSystemListener |– SpringUtil |– SteppingLooper |– SynchronousLooper 整体的结构就是这样的，下面我们来详细的介绍下每个类的作用和功能 以及rebond是怎么运作的 （二） rebond的每个类的作用 ui文件夹下utils： 这个不用多说 此类提供创建四种视图布局分别为 createMatchParams(); createWrapParams(); createWrapMatchParams(); createMatchWrapParams(); ui文件夹下SpringConfiguratorView（可省略） 这个我仔细看了下 发现可能是原demo有个手动滑动设置张力摩擦力的seekbar 这里不需要用到 所以忽略掉 然而重要的是我们要清楚在Spring中，弹簧的运动轨迹遵循胡克定律 要我们的弹簧能够弹起来需要我们手动设置张力（TENSION）和摩擦力（FRICTION） SpringConfig 这里是设置弹簧张力和拉力的类，类中声明Spring的张力和摩擦力，在这个类中我们可以通过调用 fromOrigamiTensionAndFriction(Tension,Friction) 方法来设置我们弹簧的张力和拉力，而这会return一个参数经过OrigamiValueConverter转换的SpringConfig对象，假如你想用默认的参数也可以通过直接调用暴露给的静态方法 SpringConfig.defaultConfig ，返回的是fromOrigamiTensionAndFriction(40.0D, 7.0D) 既默认40 70 SpringConfigRegistry 放置大批量SpringConfig的类库。在SpringConfigRegistry中 声明了一个SpringConfig的map集合，主要的作用就是add和remove SpringConfig 在下文SpringChain会提到 OrigamiValueConverter 在SpringConfig中提到，设置张力和摩擦力经过此类进行一个转换，这里代码如下： public OrigamiValueConverter() { } public static double tensionFromOrigamiValue(double oValue) { return oValue == 0.0D?0.0D:(oValue - 30.0D) * 3.62D + 194.0D; } public static double origamiValueFromTension(double tension) { return tension == 0.0D?0.0D:(tension - 194.0D) / 3.62D + 30.0D; } public static double frictionFromOrigamiValue(double oValue) { return oValue == 0.0D?0.0D:(oValue - 8.0D) * 3.0D + 25.0D; } public static double origamiValueFromFriction(double friction) { return friction SpringSystem SpringSystem 继承于BaseSpringSystem 内部隐藏了它的构造方法，我的需要使用它的静态方法create() ，这个方法自动为我们创建了一个SpringLooper，我们来看看这个方法返回的数据 return new SpringSystem(AndroidSpringLooperFactory.createSpringLooper());这也是我们在使用弹簧功能前提，我们需要调用这个方法得到一个弹簧，之后再对这个弹簧进行基本的设置 AndroidSpringLooperFactory 在SpringSystem 我们提到，使用rebond时，自动为我们creat一个SpringLooper，此create方法根据API是否&gt;16(4.0) 为界限，自动返回不同的AndroidSpringLooper实例，不同的类又共同继承SpringLooper，也就是说 ，在这个类中，主要的作用就是根据api不同创建不同的AndroidSpringLooper对不同版本进行适配，AndroidSpringLooper 也就是looper，调用的是BaseSpringSystem的 对looper进行的迭代计算器，做的就是不断的更新SpringSystem的状态。 SpringLooper 上面说到以4.0为界限分别返回继承SpringLooper的不同的实例，在SpringLooper这个抽象类中，有两个抽象方法start()和stop()，子类根据自身代码来操作Looper的开始和结束需要做的事情，其实主要是调用了BaseSpringSystem的loop方法。 BaseSpringSystem 在BaseSpringSystem中维护了一个SpringSystemListener数组，可以进行addListener或者removelistner的操作， 并且此类提供了对Spring的注册及初始化，对弹簧运动进行迭代计算，以及loop的迭代计算，可以说 这个类是维护弹簧持续运动计算的一个类 ，概括来说 这个类为我们创建了一个弹簧该有的东西，弹簧的运动监听，弹簧的物理运动， 主要代码如下： 123456789101112131415161718192021222324252627282930313233343536 //loop的迭代计算 public void loop(double ellapsedMillis) &#123; Iterator i$ = this.mListeners.iterator(); SpringSystemListener listener; while(i$.hasNext()) &#123; listener = (SpringSystemListener)i$.next(); listener.onBeforeIntegrate(this); &#125; this.advance(ellapsedMillis); if(this.mActiveSprings.isEmpty()) &#123; this.mIdle = true; &#125; i$ = this.mListeners.iterator(); while(i$.hasNext()) &#123; listener = (SpringSystemListener)i$.next(); listener.onAfterIntegrate(this); &#125; if(this.mIdle) &#123; this.mSpringLooper.stop(); &#125; // Spring 物理运动计算void advance(double deltaTime) &#123; Iterator i$ = this.mActiveSprings.iterator(); while(i$.hasNext()) &#123; Spring spring = (Spring)i$.next(); if(spring.systemShouldAdvance()) &#123; spring.advance(deltaTime / 1000.0D); &#125; else &#123; this.mActiveSprings.remove(spring); &#125; Spring 当当当当~ 这就是我们的弹簧啦，在这个类中详细的计算弹簧运动的物理计算 ：代码有点多。我们可以详细的了解下弹簧的运动过程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990void advance(double realDeltaTime) &#123; boolean isAtRest = this.isAtRest(); if(!isAtRest || !this.mWasAtRest) &#123; double adjustedDeltaTime = realDeltaTime; if(realDeltaTime &gt; 0.064D) &#123; adjustedDeltaTime = 0.064D; &#125; this.mTimeAccumulator += adjustedDeltaTime; double tension = this.mSpringConfig.tension; double friction = this.mSpringConfig.friction; double position = this.mCurrentState.position; double velocity = this.mCurrentState.velocity; double tempPosition = this.mTempState.position; double dvdt; double tempVelocity; for(tempVelocity = this.mTempState.velocity; this.mTimeAccumulator &gt;= 0.001D; velocity += dvdt * 0.001D) &#123; this.mTimeAccumulator -= 0.001D; if(this.mTimeAccumulator &lt; 0.001D) &#123; this.mPreviousState.position = position; this.mPreviousState.velocity = velocity; &#125; double aAcceleration = tension * (this.mEndValue - tempPosition) - friction * velocity; tempPosition = position + velocity * 0.001D * 0.5D; tempVelocity = velocity + aAcceleration * 0.001D * 0.5D; double bVelocity = tempVelocity; double bAcceleration = tension * (this.mEndValue - tempPosition) - friction * tempVelocity; tempPosition = position + tempVelocity * 0.001D * 0.5D; tempVelocity = velocity + bAcceleration * 0.001D * 0.5D; double cVelocity = tempVelocity; double cAcceleration = tension * (this.mEndValue - tempPosition) - friction * tempVelocity; tempPosition = position + tempVelocity * 0.001D; tempVelocity = velocity + cAcceleration * 0.001D; double dAcceleration = tension * (this.mEndValue - tempPosition) - friction * tempVelocity; double dxdt = 0.16666666666666666D * (velocity + 2.0D * (bVelocity + cVelocity) + tempVelocity); dvdt = 0.16666666666666666D * (aAcceleration + 2.0D * (bAcceleration + cAcceleration) + dAcceleration); position += dxdt * 0.001D; &#125; this.mTempState.position = tempPosition; this.mTempState.velocity = tempVelocity; this.mCurrentState.position = position; this.mCurrentState.velocity = velocity; if(this.mTimeAccumulator &gt; 0.0D) &#123; this.interpolate(this.mTimeAccumulator / 0.001D); &#125; if(this.isAtRest() || this.mOvershootClampingEnabled &amp;&amp; this.isOvershooting()) &#123; if(tension &gt; 0.0D) &#123; this.mStartValue = this.mEndValue; this.mCurrentState.position = this.mEndValue; &#125; else &#123; this.mEndValue = this.mCurrentState.position; this.mStartValue = this.mEndValue; &#125; this.setVelocity(0.0D); isAtRest = true; &#125; boolean notifyActivate = false; if(this.mWasAtRest) &#123; this.mWasAtRest = false; notifyActivate = true; &#125; boolean notifyAtRest = false; if(isAtRest) &#123; this.mWasAtRest = true; notifyAtRest = true; &#125; Iterator i$ = this.mListeners.iterator(); while(i$.hasNext()) &#123; SpringListener listener = (SpringListener)i$.next(); if(notifyActivate) &#123; listener.onSpringActivate(this); &#125; listener.onSpringUpdate(this); if(notifyAtRest) &#123; listener.onSpringAtRest(this); &#125; &#125; &#125; &#125; 这里面详细的定义了弹簧运动的各种东西，比如详细的记录弹簧运动到某个阶段的值（弹簧运动的物理状态）， 运动到某个阶段的弹簧的长度等等 。 ChoreographerCompat（可省略） 貌似是舞蹈者 舞蹈者就是控制图形动画和ui的类 详细可以看这篇文章，这里详细的介绍android舞蹈者的作用这个类根据Api是否》=16 （4.0） 控制不同api延迟或者立即 post和remove Choreographer的Callback 这里的运用貌似是在AnimationQuee中用到，但是AnimationQuee 在实际的代码中也并未用到，所以这里可以省略不谈 看别人说好像用AnimationQuee应该是有什么坑，我觉得应该是适配的坑，，。AnimationQuee的介绍也省略 SpringChain SpringChain 顾名思义，Spring连锁（也就是多个Spring的连锁）。如果你想多个view设置弹簧功能的需求，就可以用到SpringChain，SpringChain会从第一个图片开始一个一个得带动下一个图片的运动（如果是单个的话用Spring就可以），在这个类里，给我们提供了一个oncreat（）的静态方法供我们使用，参数依次为主拉力，主摩擦力，辅助拉力，辅助摩擦力，之后我们给每个view通过springChain.addSpring添加到队列中，并且设置SpringListener，最后通过springChain.setControlSpringIndex(0).getControlSpring().setEndValue(0);设置刚开始的弹簧的index 比如一个4个view 第一个先动的是4 那么最后一个就是0 让我们来看看具体的代码： 12345678910111213141516171819202122232425262728293031323334353637/** * 将一个弹簧添加到将返回给所提供侦听器的链中。 * @param 监听SpringChain中的Spring 并且通知更新它 * @return this SpringChain for chaining（返回SpringChain的链接） */ public SpringChain addSpring(final SpringListener listener) &#123; // We listen to each spring added to the SpringChain and dynamically chain the springs together // whenever the control spring state is modified. Spring spring = mSpringSystem .createSpring() .addListener(this) .setSpringConfig(mAttachmentSpringConfig); mSprings.add(spring); mListeners.add(listener); return this; &#125; /**/ /设置控制弹簧的索引。此弹簧将带动所有弹簧的位置进行运动 * Set the index of the control spring. This spring will drive the positions of all the springs * before and after it in the list when moved. * @param i the index to use for the control spring（指针i 用于控制弹簧） * @return this SpringChain */ public SpringChain setControlSpringIndex(int i) &#123; mControlSpringIndex = i; Spring controlSpring = mSprings.get(mControlSpringIndex); if (controlSpring == null) &#123; return null; &#125; for (Spring spring : mSpringSystem.getAllSprings()) &#123; spring.setSpringConfig(mAttachmentSpringConfig); &#125; getControlSpring().setSpringConfig(mMainSpringConfig); return this; &#125;]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[超级干货系列 hexo+gihub搭建博客]]></title>
    <url>%2FHellopcj%2F2017%2F09%2F08%2Fa-chrismas-ico%2F</url>
    <content type="text"><![CDATA[相信很多盆友们都想搭建属于自己的博客，但是想要拥有自己独立的服务器和域名还是蛮麻烦的，既要进行网站备案（还不一定能通过）还要自己搞网页的样式等等。 有了gihub就可以轻松搭建自己的博客。gihub+hexo搭建博客的原理大致是这样的， hexo生成本地静态博客 通过hexo与自己的gihub相关联，将自己的静态博客git到自己的gihub中。通过gihub就可以轻松的查看自己的博客。下面就让我们详细的了解下搭建的步骤： 一：准备工作 安装node node的官方网址为：http://nodejs.cn/download/ 安装git git的官方网址：https://git-scm.com/downloads 将node和git下载下来 无脑下一步即可实现安装 测试电脑中node和git是否安装成功在控制台输入以下命令： git –version node -v npm -v 二：创建gihub page博客 在自己的gihub创建一个以自己账户名相同的 repository 创建完毕点击setting 设置page的样式 并且发布此时我们得到了一个默认的gihub博客页面 三：下载安装hexo 在命令行输入npm install hexo-cli -g等待安装成功 如果出现warn 可尝试sudo npm install -g hexo-cli 在user下新建一个名为MyBlog的文件（这里一MyBlog为例）利用命令行切换到刚才新建的MyBlogcd ~/MyBloghexo init MyBlognpm install这时等待hexo初始化到MyBlog文件中此时 ls 我们可以看到文件中有这样的结构|– _config.yml|– package.json|– scaffolds|– source| |– _drafts| |– _posts|– themes 安装hexo server 输入以下命令：sudo npm install hexo-serverhexo ghexo server可以看到下图 将链接复制到Safari可以看到默认的hexo主题页面 四：Hexo与gihub相关联 打开MyBlog文件夹 在主目录中可以找到_config.yml文件 用文本编辑器打开 将链接换成自己的gihub仓库的地址 输入命令行 npm install hexo-deployer-git –save 将生成静态页面并部署到github的仓库中，执行： hexo g hexo deploy 或者 hexo d -g ** INFO Deploy done: git 即上传成功，这时就可以通过gihub仓库 看到本地上传的资源 五：Hexo的基本配置和Hexo主题样式 hexo支持多种主题样式，大家可以从https://hexo.io/themes/ 寻找自己喜欢的主题样式或者从这里找到自己心仪的主题 https://www.zhihu.com/question/24422335博主这里用到的是(litten/hexo-theme-yilia)的主题， 以此为例 控制台切换到MyBlog文件夹下 输入命令行安装主题：git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia安装less，主题使用less作为css预处理工具：npm install hexo-renderer-less –save安装feed生成RSS：npm install hexo-generator-feed –save安装json-content，用于生成静态站点数据，提供搜索功能的数据源：npm install hexo-generator-json-content –save开启标签页：hexo new page tags修改MyBlog/source/tags/index.md的源数据：layout: tagsnoDate: truecomments: false—保存 修改MyBlog文件夹下（主目录）_Config.yml文件 theme: yilia ——注意 修改_Config.yml 文件 :后面都必须有一个空格 不然会报错！每个key后面都有一个空格然后再加value——输入命令行hexo cleanhexo ghexo deploy将本地修改的文件 上传到gihub上也可以先 hexo server本地查看网站 确认无误后再上传 六：需要注意的事 需要注意的事 1：修改_Config.yml 文件 :后面都必须有一个空格 不然会报错（重要的事情说三遍） 2：发布到gihub发现自己的网页样式缺失 这时候99%的原因是_config.yml 的url和root的路径有问题 除了修改主目录下的——config.yml文件 此外在themes文件夹下 你用到的 样式里面的_config.yml 的root 和url也需要修改 [具体如图](/Hellopcj/assets/blogimg/configroot.png) 这里面的url是你自己博客的地址 root是在自己项目gihub上存放网页的目录 如果还是改不好 可以在Safair调出控制台 查看自己gihub网页的具体结构 调出Safari控制台的步骤（在启动Safari的基础上） 点击左侧系统偏好设置&gt;高级 勾选最下方 在菜单栏中显示“开发”菜单 回到Gihub blog页面 右键鼠标点击 检查元素 即可查看具体内容 ps: 如果你和我同样用的是NexT主题 推荐其网站国内翻译的官网吧属于]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
  </entry>
</search>
