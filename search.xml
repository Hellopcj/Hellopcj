<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mepaidemo]]></title>
    <url>%2FHellopcj%2F2017%2F10%2F10%2Fmepaidemo%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[MAC系统下编译FFmpeg-Android （从编译到移植Androidstudio成功）(二)]]></title>
    <url>%2FHellopcj%2F2017%2F10%2F10%2Fffmpegjni%2F</url>
    <content type="text"><![CDATA[hello 大家好，上一篇文章中提到了如何在mac下编译适配于Android的ffmpeg so文件库，这篇文章给大家介绍下如何运用编译好的类库进行jni调用。 在上一篇文章中我们在文件夹中得到一个include文件夹和一个包含了so文件的lib文件夹，在include文件夹内分别有libavcodec,libavfilter,libavformat,libavutil,libswresample,libswscale文件夹，下面是具有全功能的ffmpeg类库各个包的功能(对号入座)： 12345678910111213141516libavcodec编码/解码库libavfilter基于帧的编辑库图（加特效） libavformatI/O多路复用/解复用库libavdevice复用/解复用库专用设备（读设备）libavutil常见的实用工具库libswresample音频重采样、格式转换和混合libpostproc后处理库libswscale颜色转换和缩放的图书馆（图像拉伸，像素格式转换） 基于以上的介绍，我们现在进行jni调用ffmpeg库 1：在Android新建一个工程，在src/main下新建一个文件夹，作者这里命名为jni： 2：将我们编译好的lib下的so文件复制粘贴到jni文件夹下同时再把编译好的include文件夹直接拷贝到jni文件夹，在jni下新建Android.mk以及Application.mk（Makefile格式的文件）以及随便起个名字的c文件（这里用的是ffmpeg.c）此时，我们看到的目录是这样的 3：我们来到MainActivity在Activityxml文件写一个按钮和TextView控件以便于测试， 在Activity中加载类库 类库的加载方法为System.loadLibrary(…Java代码中不包含前面的“lib”和后面的“.so”) 并声明一个stringFromJNI()方法。（声明c方法前面需要加上native） 此时的MainActivity的代码是这样的 1234567891011121314151617181920212223242526public class MainActivity extends AppCompatActivity &#123; private TextView tv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tv= (Button) findViewById(R.id.tv); &#125; public native String stringFromJNI(); static &#123; System.loadLibrary("avcodec-57"); System.loadLibrary("avfilter-6"); System.loadLibrary("avformat-57"); System.loadLibrary("avutil-55"); System.loadLibrary("swresample-2"); System.loadLibrary("swscale-4"); System.loadLibrary("ffmpeg"); &#125; public void showFormat(View view)&#123; tv.setText(stringFromJNI()); &#125;&#125; 现在我们看到stringFromJNI()是红色的，我们需要将MainActivity运用javah生成一个C\C++头文件 此时运用Androidstudio下的terminal命令行，运用 1javah MainActivity的全路径 得到一个c文件 如下图所示： 将生成的MainActivity的C\C++头文件移动到jni目录下 4：打开Android.mk添加以下代码 12345678910111213141516171819202122232425262728293031323334LOCAL_PATH := $(call my-dir)# FFmpeg libraryinclude $(CLEAR_VARS)LOCAL_MODULE := avcodecLOCAL_SRC_FILES := libavcodec-57.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := avfilterLOCAL_SRC_FILES := libavfilter-6.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := avformatLOCAL_SRC_FILES := libavformat-57.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := avutilLOCAL_SRC_FILES := libavutil-55.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := swresampleLOCAL_SRC_FILES := libswresample-2.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := swscaleLOCAL_SRC_FILES := libswscale-4.soinclude $(PREBUILT_SHARED_LIBRARY)# Programinclude $(CLEAR_VARS)LOCAL_MODULE := ffmpegLOCAL_SRC_FILES := ffmpeg.cLOCAL_C_INCLUDES += $(LOCAL_PATH)/includeLOCAL_LDLIBS := -llog -lzLOCAL_SHARED_LIBRARIES := avcodec avfilter avformat avutil swresample swscaleinclude $(BUILD_SHARED_LIBRARY) 其中 123LOCAL_SRC_FILES := libavcodec-57.so//自己打出来的so包的名字LOCAL_MODULE := ffmpegLOCAL_SRC_FILES := ffmpeg.c//改成你创建的c文件的名字 5：Application.mk添加以下代码：(可以不添加 在build.gradle添加了过滤) 12APP_ABI := armeabi-v7aAPP_MODULES := libffmpeg 6：利用Terminal进入到jni命令 进行build 输入如下命令 1ndk-build 7:编写ffmpeg.cpp代码 此时ffmpeg需要继承重写javah生成的头文件的方法:笔者生成的头文件的方法为 1JNIEXPORT jstring JNICALL Java_hi_testffmpeg_MainActivity_stringFromJNI 所以ffmpeg.cpp中代码如下 12345678JNIEXPORT jstring JNICALL Java_hi_testffmpeg_MainActivity_stringFromJNI(JNIEnv *env, jobject obj)&#123; char info[10000] = &#123;0&#125;; av_register_all(); sprintf(info, "%s\n", avcodec_configuration()); //LOGE("%s", info); return (*env)-&gt;NewStringUTF(env, info);&#125; 8：在App下的buidl.gradle下添加abi过滤 选择输出支持手机的abi的cpu架构 （一般的手机都是Arm架构） 菜鸡可以参考这篇文章（http://www.cnblogs.com/Bugtags2015/p/5578541.html） 代码如下： 123456789101112131415161718defaultConfig &#123; applicationId "hi.test" minSdkVersion 15 targetSdkVersion 26 versionCode 1 versionName "1.0" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" // abi过滤 ndk&#123; abiFilters "armeabi","armeabi-v7a" &#125; &#125; externalNativeBuild&#123; ndkBuild&#123; path "src/main/jni/Android.mk" &#125; &#125; 同步代码，这是可以看到文件的结构是这样的： 这时我们就可以完美的运行啦]]></content>
      <categories>
        <category>Android音频</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MAC系统下编译FFmpeg-Android （从编译到移植Androidstudio成功）(一)]]></title>
    <url>%2FHellopcj%2F2017%2F09%2F22%2Fview%2F</url>
    <content type="text"><![CDATA[大家好，因为我最近突然对Android的音频产生了浓厚的兴趣，所以带来了今天这篇文章。（打包过程都是我自己一步一步操作，所以比较详细） 作为老牌音频剪辑的FFmpeg 被广泛的应用，包括美拍等短视频编辑都是用的FFmpeg，可以说很多的Android处理音视频都是用的FFmpeg 什么是FFmpeg？为什么选择FFmpeg？FFmpeg是一套比较完善的音视频编解码框架，里面包含了整套诸如格式转换，音视频录制的解决方案。采用LGPL或GPL许可证,使用FFmpeg可以对音视频进行渲染和合成等操作，FFmpeg的功能非常强大，不仅可以采集图像，对屏幕进行录制，同时还支持以RTP方式将视频流传送给支持RTSP的流媒体服务器，支持直播应用。 FFmpeg具有很强的可移植性，可以在移植到不同操作系统 支持linux ，windows，OS X在编译的时候 可以根据操作系统的不同下载不同操作系统的资源包。本文为mac系统, FFmpeg编译流程FFmpeg的大致流程图为下图（用的雷神的图） 值得注意的是FFmpeg提供几乎各种类型的解码器，但是编码器确少之又少 环境资源配置及编译具体流程1:确保你的电脑已经具备编译开发环境（ndk）安装了AndroidStudio软件环境的都应该下载了ndk这里不在赘述。 这里作者通过androidstudio以前的配置找到了 2：直接访问官网下载FFmpeg源码。 这里作者直接输入git命令获得FFmpeg： git clone git://source.ffmpeg.org/ffmpeg.git ffmpeg （确保下载的ffmpeg是适合你的电脑操作系统） 3：新建一个名为homework的文件夹（以homework为例）FFmpeg解压后可以看到有一个名为ffmpeg-3.3.4的文件夹（这里将文件夹改为ffmpeg2 以便于后期操作），将其放到homework文件夹下，打开ffmpeg2文件夹下找到configure文件，用记事本打开找到 SLIBNAME_WITH_MAJOR=’$(SLIBNAME).$(LIBMAJOR)’LIB_INSTALL_EXTRA_CMD=’$$(RANLIB)”$(LIBDIR)/$(LIBNAME)”‘SLIB_INSTALL_NAME=’$(SLIBNAME_WITH_VERSION)’SLIB_INSTALL_LINKS=’$(SLIBNAME_WITH_MAJOR)$(SLIBNAME)’ 替换为： SLIBNAME_WITH_MAJOR=’$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)’LIB_INSTALL_EXTRA_CMD=’$$(RANLIB)”$(LIBDIR)/$(LIBNAME)”‘SLIB_INSTALL_NAME=’$(SLIBNAME_WITH_MAJOR)’SLIB_INSTALL_LINKS=’$(SLIBNAME)’ 以便于生成Android开发环境能用的so包（根据雷神的说法，编译后默认生成的是so+版本号的格式，而Android只支持文件结尾为.so的资源库） 4:在ffmpeg2下新建一个文件夹为ffmpegtemp 和一个脚本文件build_android.sh这时运行脚本文件一般都有Permission denied字样 这是因为新建的脚本没有权限 切换到ffmpeg2下输入命令行： chmod +x build_android.sh 5:脚本文件的内容网上有很多例子，需要针对我们工程的需求来生成不同的类库 下面举例一种： 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#!/bin/bashexport TMPDIR=/Users/user-puchunjie/homework/ffmpeg-3.0/ffmpegtemp#这句很重要，不然会报错 unable to create temporary file in# NDK的路径，根据自己的安装位置进行设置NDK=/Users/user-puchunjie/Library/Android/sdk/ndk-bundle# 编译针对的平台，可以根据自己的需求进行设置# 这里选择最低支持android-14, arm架构，生成的so库是放在# libs/armeabi文件夹下的，若针对x86架构，要选择arch-x86PLATFORM=$NDK/platforms/android-16/arch-arm# 工具链的路径，根据编译的平台不同而不同# arm-linux-androideabi-4.9与上面设置的PLATFORM对应，4.9为工具的版本号，# 根据自己安装的NDK版本来确定，一般使用最新的版本TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64function build_one&#123;./configure \ --prefix=$PREFIX \ --enable-shared \ --disable-static \ --disable-doc \ --disable-ffmpeg \ --disable-ffplay \ --disable-ffprobe \ --disable-ffserver \ --disable-avdevice \ --disable-doc \ --disable-symver \ --cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \ --target-os=linux \ --arch=arm \ --enable-cross-compile \ --sysroot=$PLATFORM \ --extra-cflags="-I$PLATFORM/usr/include" \# --extra-ldflags="-L$PLATFORM/usr/lib -nostdlib" \ #①这一句我注释掉了，不然会报 ld: -single_module: unknown option$ADDITIONAL_CONFIGURE_FLAGsed -i '' 's/HAVE_LRINT 0/HAVE_LRINT 1/g' config.hsed -i '' 's/HAVE_LRINTF 0/HAVE_LRINTF 1/g' config.hsed -i '' 's/HAVE_ROUND 0/HAVE_ROUND 1/g' config.hsed -i '' 's/HAVE_ROUNDF 0/HAVE_ROUNDF 1/g' config.hsed -i '' 's/HAVE_TRUNC 0/HAVE_TRUNC 1/g' config.hsed -i '' 's/HAVE_TRUNCF 0/HAVE_TRUNCF 1/g' config.hsed -i '' 's/HAVE_CBRT 0/HAVE_CBRT 1/g' config.hsed -i '' 's/HAVE_RINT 0/HAVE_RINT 1/g' config.hmake cleanmake -j4make install&#125;# arm v7vfpCPU=armv7-aOPTIMIZE_CFLAGS="-mfloat-abi=softfp -mfpu=vfp -marm -march=$CPU "PREFIX=./android/$CPU-vfpADDITIONAL_CONFIGURE_FLAG=build_one# CPU=armv# PREFIX=$(pwd)/android/$CPU# ADDI_CFLAGS="-marm"# build_one#arm v6#CPU=armv6#OPTIMIZE_CFLAGS="-marm -march=$CPU"#PREFIX=./android/$CPU #ADDITIONAL_CONFIGURE_FLAG=#build_one#arm v7vfpv3# CPU=armv7-a# OPTIMIZE_CFLAGS="-mfloat-abi=softfp -mfpu=vfpv3-d16 -marm -march=$CPU "# PREFIX=./android/$CPU# ADDITIONAL_CONFIGURE_FLAG=# build_one#arm v7n#CPU=armv7-a#OPTIMIZE_CFLAGS="-mfloat-abi=softfp -mfpu=neon -marm -march=$CPU -mtune=cortex-a8"#PREFIX=./android/$CPU #ADDITIONAL_CONFIGURE_FLAG=--enable-neon#build_one#arm v6+vfp#CPU=armv6#OPTIMIZE_CFLAGS="-DCMP_HAVE_VFP -mfloat-abi=softfp -mfpu=vfp -marm -march=$CPU"#PREFIX=./android/$&#123;CPU&#125;_vfp #ADDITIONAL_CONFIGURE_FLAG=#build_one （我已经把配置文件上传到我的百度网盘 大家可以下载）执行刚才新建的脚本文件，命令行为下： ./build_android.sh 如果有提示: yasm/nasm not found or too old. Use –disable-yasm for a crippled build. 解决方法：手动下载yasm使用命令行切换到解压的yasm文件夹下输入以下命令： ./configure &amp;&amp; make -j 4 &amp;&amp; sudo make install参考网页 重新执行脚本文件build_android即可 6:这时候我们就可以在ffmpeg2下看到有一个android文件夹 在lib中可以找到我们编译出来的so文件]]></content>
      <categories>
        <category>Android音频</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Facebook rebond 弹簧功能源码分析]]></title>
    <url>%2FHellopcj%2F2017%2F09%2F14%2Frebond%2F</url>
    <content type="text"><![CDATA[相信大家在项目上或多或少的用到了弹簧功能，比较常用和方便的就是facebook的开源库rebond,想要深入的了解这个开源库的使用方法就需要我们源码分析（read the fucking source code！）整个开源库的功能实现。我自己也通过rebond写了个demo 有兴趣的可以下载了解下（代码都有注释 适合菜鸟初学者了解 大神略过） 废话不多说，下面我们就开始分析源代码（very fucking detailed！） rebond的配置 在gradle 进行配置： 123dependencies &#123;compile 'com.facebook.rebound:rebound:0.3.8'&#125; 或者maven部署rebond库 12345&lt;dependency&gt; &lt;groupId&gt;com.facebook.rebound&lt;/groupId&gt; &lt;artifactId&gt;rebound&lt;/artifactId&gt; &lt;version&gt;0.3.8&lt;/version&gt;&lt;/dependency&gt; 这时候我们可以看到rebond的目录结构： |– ui| |– utils （layout的工具类 提供create四个不同参数的layout布局 例如：宽高自适应父类布局等）| |– SpringConfiguratorView（弹簧（Spring） view 配置器Spring 配置信息 包含Spring张力值0-200 摩擦力0-50）|– AndroidSpringLooperFactory |– AnimationQueue|– BaseSpringSystem|– BuildConfig (包含了开源库rebond的版本信息等) |– ChoreographerCompat |– OrigamiValueConverter |– SimpleSpringListener （实现了SpringLsitener接口） |– Spring |– SpringChain |– SpringConfig |– SpringConfigRegistry |– SpringListener （包含Spring 四个运动状态的方法） |– SpringLooper |– SpringSystem |– SpringSystemListener |– SpringUtil |– SteppingLooper |– SynchronousLooper 整体的结构就是这样的，下面我们来详细的介绍下每个类的作用和功能 以及rebond是怎么运作的 rebond的每个类的作用 ui文件夹下utils： 这个不用多说 此类提供创建四种视图布局分别为 createMatchParams(); createWrapParams(); createWrapMatchParams(); createMatchWrapParams(); ###ui文件夹下SpringConfiguratorView（可省略）### 这个我仔细看了下 发现可能是原demo有个手动滑动设置张力摩擦力的seekbar 这里不需要用到 所以忽略掉 然而重要的是我们要清楚在Spring中，弹簧的运动轨迹遵循胡克定律 要我们的弹簧能够弹起来需要我们手动设置张力（TENSION）和摩擦力（FRICTION） SpringConfig这里是设置弹簧张力和拉力的类，类中声明Spring的张力和摩擦力，在这个类中我们可以通过调用 fromOrigamiTensionAndFriction(Tension,Friction) 方法来设置我们弹簧的张力和拉力，而这会return一个参数经过OrigamiValueConverter转换的SpringConfig对象，假如你想用默认的参数也可以通过直接调用暴露给的静态方法 SpringConfig.defaultConfig ，返回的是fromOrigamiTensionAndFriction(40.0D, 7.0D) 既默认40 70 SpringConfigRegistry放置大批量SpringConfig的类库。在SpringConfigRegistry中 声明了一个SpringConfig的map集合，主要的作用就是add和remove SpringConfig 在下文SpringChain会提到 ###OrigamiValueConverter 在SpringConfig中提到，设置张力和摩擦力经过此类进行一个转换，这里代码如下： public OrigamiValueConverter() { } public static double tensionFromOrigamiValue(double oValue) { return oValue == 0.0D?0.0D:(oValue - 30.0D) * 3.62D + 194.0D; } public static double origamiValueFromTension(double tension) { return tension == 0.0D?0.0D:(tension - 194.0D) / 3.62D + 30.0D; } public static double frictionFromOrigamiValue(double oValue) { return oValue == 0.0D?0.0D:(oValue - 8.0D) * 3.0D + 25.0D; } public static double origamiValueFromFriction(double friction) { return friction SpringSystemSpringSystem 继承于BaseSpringSystem 内部隐藏了它的构造方法，我的需要使用它的静态方法create() ，这个方法自动为我们创建了一个SpringLooper，我们来看看这个方法返回的数据 return new SpringSystem(AndroidSpringLooperFactory.createSpringLooper());这也是我们在使用弹簧功能前提，我们需要调用这个方法得到一个弹簧，之后再对这个弹簧进行基本的设置 ###AndroidSpringLooperFactory 在SpringSystem 我们提到，使用rebond时，自动为我们creat一个SpringLooper，此create方法根据API是否&gt;16(4.0) 为界限，自动返回不同的AndroidSpringLooper实例，不同的类又共同继承SpringLooper，也就是说 ，在这个类中，主要的作用就是根据api不同创建不同的AndroidSpringLooper对不同版本进行适配，AndroidSpringLooper 也就是looper，调用的是BaseSpringSystem的 对looper进行的迭代计算器，做的就是不断的更新SpringSystem的状态。 SpringLooper上面说到以4.0为界限分别返回继承SpringLooper的不同的实例，在SpringLooper这个抽象类中，有两个抽象方法start()和stop()，子类根据自身代码来操作Looper的开始和结束需要做的事情，其实主要是调用了BaseSpringSystem的loop方法。 BaseSpringSystem 在BaseSpringSystem中维护了一个SpringSystemListener数组，可以进行addListener或者removelistner的操作， 并且此类提供了对Spring的注册及初始化，对弹簧运动进行迭代计算，以及loop的迭代计算，可以说 这个类是维护弹簧持续运动计算的一个类 ，概括来说 这个类为我们创建了一个弹簧该有的东西，弹簧的运动监听，弹簧的物理运动， 主要代码如下： 123456789101112131415161718192021222324252627282930313233343536 //loop的迭代计算 public void loop(double ellapsedMillis) &#123; Iterator i$ = this.mListeners.iterator(); SpringSystemListener listener; while(i$.hasNext()) &#123; listener = (SpringSystemListener)i$.next(); listener.onBeforeIntegrate(this); &#125; this.advance(ellapsedMillis); if(this.mActiveSprings.isEmpty()) &#123; this.mIdle = true; &#125; i$ = this.mListeners.iterator(); while(i$.hasNext()) &#123; listener = (SpringSystemListener)i$.next(); listener.onAfterIntegrate(this); &#125; if(this.mIdle) &#123; this.mSpringLooper.stop(); &#125; // Spring 物理运动计算void advance(double deltaTime) &#123; Iterator i$ = this.mActiveSprings.iterator(); while(i$.hasNext()) &#123; Spring spring = (Spring)i$.next(); if(spring.systemShouldAdvance()) &#123; spring.advance(deltaTime / 1000.0D); &#125; else &#123; this.mActiveSprings.remove(spring); &#125; Spring当当当当~ 这就是我们的弹簧啦，在这个类中详细的计算弹簧运动的物理计算 ：代码有点多。我们可以详细的了解下弹簧的运动过程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990void advance(double realDeltaTime) &#123; boolean isAtRest = this.isAtRest(); if(!isAtRest || !this.mWasAtRest) &#123; double adjustedDeltaTime = realDeltaTime; if(realDeltaTime &gt; 0.064D) &#123; adjustedDeltaTime = 0.064D; &#125; this.mTimeAccumulator += adjustedDeltaTime; double tension = this.mSpringConfig.tension; double friction = this.mSpringConfig.friction; double position = this.mCurrentState.position; double velocity = this.mCurrentState.velocity; double tempPosition = this.mTempState.position; double dvdt; double tempVelocity; for(tempVelocity = this.mTempState.velocity; this.mTimeAccumulator &gt;= 0.001D; velocity += dvdt * 0.001D) &#123; this.mTimeAccumulator -= 0.001D; if(this.mTimeAccumulator &lt; 0.001D) &#123; this.mPreviousState.position = position; this.mPreviousState.velocity = velocity; &#125; double aAcceleration = tension * (this.mEndValue - tempPosition) - friction * velocity; tempPosition = position + velocity * 0.001D * 0.5D; tempVelocity = velocity + aAcceleration * 0.001D * 0.5D; double bVelocity = tempVelocity; double bAcceleration = tension * (this.mEndValue - tempPosition) - friction * tempVelocity; tempPosition = position + tempVelocity * 0.001D * 0.5D; tempVelocity = velocity + bAcceleration * 0.001D * 0.5D; double cVelocity = tempVelocity; double cAcceleration = tension * (this.mEndValue - tempPosition) - friction * tempVelocity; tempPosition = position + tempVelocity * 0.001D; tempVelocity = velocity + cAcceleration * 0.001D; double dAcceleration = tension * (this.mEndValue - tempPosition) - friction * tempVelocity; double dxdt = 0.16666666666666666D * (velocity + 2.0D * (bVelocity + cVelocity) + tempVelocity); dvdt = 0.16666666666666666D * (aAcceleration + 2.0D * (bAcceleration + cAcceleration) + dAcceleration); position += dxdt * 0.001D; &#125; this.mTempState.position = tempPosition; this.mTempState.velocity = tempVelocity; this.mCurrentState.position = position; this.mCurrentState.velocity = velocity; if(this.mTimeAccumulator &gt; 0.0D) &#123; this.interpolate(this.mTimeAccumulator / 0.001D); &#125; if(this.isAtRest() || this.mOvershootClampingEnabled &amp;&amp; this.isOvershooting()) &#123; if(tension &gt; 0.0D) &#123; this.mStartValue = this.mEndValue; this.mCurrentState.position = this.mEndValue; &#125; else &#123; this.mEndValue = this.mCurrentState.position; this.mStartValue = this.mEndValue; &#125; this.setVelocity(0.0D); isAtRest = true; &#125; boolean notifyActivate = false; if(this.mWasAtRest) &#123; this.mWasAtRest = false; notifyActivate = true; &#125; boolean notifyAtRest = false; if(isAtRest) &#123; this.mWasAtRest = true; notifyAtRest = true; &#125; Iterator i$ = this.mListeners.iterator(); while(i$.hasNext()) &#123; SpringListener listener = (SpringListener)i$.next(); if(notifyActivate) &#123; listener.onSpringActivate(this); &#125; listener.onSpringUpdate(this); if(notifyAtRest) &#123; listener.onSpringAtRest(this); &#125; &#125; &#125; &#125; 这里面详细的定义了弹簧运动的各种东西，比如详细的记录弹簧运动到某个阶段的值（弹簧运动的物理状态）， 运动到某个阶段的弹簧的长度等等 。 ChoreographerCompat（可省略） 貌似是舞蹈者 舞蹈者就是控制图形动画和ui的类 详细可以看这篇文章，这里详细的介绍android舞蹈者的作用 这个类根据Api是否》=16 （4.0） 控制不同api延迟或者立即 post和remove Choreographer的Callback 这里的运用貌似是在AnimationQuee中用到，但是AnimationQuee 在实际的代码中也并未用到，所以这里可以省略不谈 看别人说好像用AnimationQuee应该是有什么坑，我觉得应该是适配的坑，，。AnimationQuee的介绍也省略 SpringChainSpringChain 顾名思义，Spring连锁（也就是多个Spring的连锁）。如果你想多个view设置弹簧功能的需求，就可以用到SpringChain，SpringChain会从第一个图片开始一个一个得带动下一个图片的运动（如果是单个的话用Spring就可以），在这个类里，给我们提供了一个oncreat（）的静态方法供我们使用，参数依次为主拉力，主摩擦力，辅助拉力，辅助摩擦力，之后我们给每个view通过springChain.addSpring添加到队列中，并且设置SpringListener，最后通过springChain.setControlSpringIndex(0).getControlSpring().setEndValue(0);设置刚开始的弹簧的index 比如一个4个view 第一个先动的是4 那么最后一个就是0 让我们来看看具体的代码： 12345678910111213141516171819202122232425262728293031323334353637/** * 将一个弹簧添加到将返回给所提供侦听器的链中。 * @param 监听SpringChain中的Spring 并且通知更新它 * @return this SpringChain for chaining（返回SpringChain的链接） */ public SpringChain addSpring(final SpringListener listener) &#123; // We listen to each spring added to the SpringChain and dynamically chain the springs together // whenever the control spring state is modified. Spring spring = mSpringSystem .createSpring() .addListener(this) .setSpringConfig(mAttachmentSpringConfig); mSprings.add(spring); mListeners.add(listener); return this; &#125; /**/ /设置控制弹簧的索引。此弹簧将带动所有弹簧的位置进行运动 * Set the index of the control spring. This spring will drive the positions of all the springs * before and after it in the list when moved. * @param i the index to use for the control spring（指针i 用于控制弹簧） * @return this SpringChain */ public SpringChain setControlSpringIndex(int i) &#123; mControlSpringIndex = i; Spring controlSpring = mSprings.get(mControlSpringIndex); if (controlSpring == null) &#123; return null; &#125; for (Spring spring : mSpringSystem.getAllSprings()) &#123; spring.setSpringConfig(mAttachmentSpringConfig); &#125; getControlSpring().setSpringConfig(mMainSpringConfig); return this; &#125;]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Android source code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超级干货系列 hexo+gihub搭建博客]]></title>
    <url>%2FHellopcj%2F2017%2F09%2F08%2Fa-chrismas-ico%2F</url>
    <content type="text"><![CDATA[相信很多盆友们都想搭建属于自己的博客，但是想要拥有自己独立的服务器和域名还是蛮麻烦的，既要进行网站备案（还不一定能通过）还要自己搞网页的样式等等。 有了gihub就可以轻松搭建自己的博客。gihub+hexo搭建博客的原理大致是这样的， hexo生成本地静态博客 通过hexo与自己的gihub相关联，将自己的静态博客git到自己的gihub中。通过gihub就可以轻松的查看自己的博客。下面就让我们详细的了解下搭建的步骤： 准备工作 安装node node的官方网址为：http://nodejs.cn/download/ 安装git git的官方网址：https://git-scm.com/downloads 将node和git下载下来 无脑下一步即可实现安装 测试电脑中node和git是否安装成功在控制台输入以下命令： git –version node -v npm -v 创建gihub page博客在自己的gihub创建一个以自己账户名相同的 repository 创建完毕点击setting 设置page的样式 并且发布此时我们得到了一个默认的gihub博客页面 下载安装hexo在命令行输入npm install hexo-cli -g等待安装成功 如果出现warn 可尝试sudo npm install -g hexo-cli 在user下新建一个名为MyBlog的文件（这里一MyBlog为例）利用命令行切换到刚才新建的MyBlogcd ~/MyBloghexo init MyBlognpm install这时等待hexo初始化到MyBlog文件中此时 ls 我们可以看到文件中有这样的结构|– _config.yml|– package.json|– scaffolds|– source| |– _drafts| |– _posts|– themes 安装hexo server 输入以下命令：sudo npm install hexo-serverhexo ghexo server可以看到下图 将链接复制到Safari可以看到默认的hexo主题页面 Hexo与gihub相关联打开MyBlog文件夹 在主目录中可以找到_config.yml文件 用文本编辑器打开 将链接换成自己的gihub仓库的地址 输入命令行 npm install hexo-deployer-git –save 将生成静态页面并部署到github的仓库中，执行： hexo g hexo deploy 或者 hexo d -g ** INFO Deploy done: git 即上传成功，这时就可以通过gihub仓库 看到本地上传的资源 Hexo的基本配置和Hexo主题样式hexo支持多种主题样式，大家可以从https://hexo.io/themes/ 寻找自己喜欢的主题样式或者从这里找到自己心仪的主题 https://www.zhihu.com/question/24422335博主这里用到的是(litten/hexo-theme-yilia)的主题， 以此为例 控制台切换到MyBlog文件夹下 输入命令行安装主题：git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia安装less，主题使用less作为css预处理工具：npm install hexo-renderer-less –save安装feed生成RSS：npm install hexo-generator-feed –save安装json-content，用于生成静态站点数据，提供搜索功能的数据源：npm install hexo-generator-json-content –save开启标签页：hexo new page tags修改MyBlog/source/tags/index.md的源数据：layout: tagsnoDate: truecomments: false—保存 修改MyBlog文件夹下（主目录）_Config.yml文件 theme: yilia ——注意 修改_Config.yml 文件 :后面都必须有一个空格 不然会报错！每个key后面都有一个空格然后再加value——输入命令行hexo cleanhexo ghexo deploy将本地修改的文件 上传到gihub上也可以先 hexo server本地查看网站 确认无误后再上传 需要注意的事需要注意 1：修改_Config.yml 文件 :后面都必须有一个空格 不然会报错（重要的事情说三遍） 2：发布到gihub发现自己的网页样式缺失 这时候99%的原因是_config.yml 的url和root的路径有问题 除了修改主目录下的——config.yml文件 此外在themes文件夹下 你用到的 样式里面的_config.yml 的root 和url也需要修改 [具体如图](/Hellopcj/assets/blogimg/configroot.png) 这里面的url是你自己博客的地址 root是在自己项目gihub上存放网页的目录 如果还是改不好 可以在Safair调出控制台 查看自己gihub网页的具体结构 调出Safari控制台的步骤（在启动Safari的基础上） 点击左侧系统偏好设置&gt;高级 勾选最下方 在菜单栏中显示“开发”菜单 回到Gihub blog页面 右键鼠标点击 检查元素 即可查看具体内容 ps: 如果你和我同样用的是NexT主题 推荐其网站国内翻译的官网吧属于 还有这个网站NexT主题评论系统]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
